<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Go vs Java深入对比系列（四）：并发编程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Go vs Java深入对比系列（四）：并发编程Go与Java并发编程谁更胜一筹？这就像问火锅和烧烤哪个更好吃一样，还真不是一句话能说清楚的。Go语言诞生之初就将并发作为语言级特性来设计，而Java则是在发展过程中不断强化其并发能力。今天我们就从设计理念、编程模型、内存模型等多个维度，来对这两种语言的并发特性做一次深度对比。 一、并发模型1.1 Java：基于对象的并发模型Java诞生于上世纪90">
<meta property="og:type" content="article">
<meta property="og:title" content="lcz的技术小窝">
<meta property="og:url" content="http://example.com/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Go vs Java深入对比系列（四）：并发编程Go与Java并发编程谁更胜一筹？这就像问火锅和烧烤哪个更好吃一样，还真不是一句话能说清楚的。Go语言诞生之初就将并发作为语言级特性来设计，而Java则是在发展过程中不断强化其并发能力。今天我们就从设计理念、编程模型、内存模型等多个维度，来对这两种语言的并发特性做一次深度对比。 一、并发模型1.1 Java：基于对象的并发模型Java诞生于上世纪90">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-06-21T10:54:12.687Z">
<meta property="article:modified_time" content="2024-06-21T10:50:13.001Z">
<meta property="article:author" content="lcz的技术小窝">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lcz的技术小窝</a>
      </h1>
      <p style="font-size: 14px; color: #a6c7b3; margin-top: 5px;">业精于勤，而荒于嬉</p>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文章列表</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Go vs Java深入对比系列（四）：并发编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-06-21T10:54:12.687Z" itemprop="datePublished">2024-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Go-vs-Java深入对比系列（四）：并发编程"><a href="#Go-vs-Java深入对比系列（四）：并发编程" class="headerlink" title="Go vs Java深入对比系列（四）：并发编程"></a>Go vs Java深入对比系列（四）：并发编程</h1><p>Go与Java并发编程谁更胜一筹？这就像问火锅和烧烤哪个更好吃一样，还真不是一句话能说清楚的。Go语言诞生之初就将并发作为语言级特性来设计，而Java则是在发展过程中不断强化其并发能力。今天我们就从设计理念、编程模型、内存模型等多个维度，来对这两种语言的并发特性做一次深度对比。</p>
<h2 id="一、并发模型"><a href="#一、并发模型" class="headerlink" title="一、并发模型"></a>一、并发模型</h2><h3 id="1-1-Java：基于对象的并发模型"><a href="#1-1-Java：基于对象的并发模型" class="headerlink" title="1.1 Java：基于对象的并发模型"></a>1.1 Java：基于对象的并发模型</h3><p>Java诞生于上世纪90年代，那时候多核处理器还不普及。它的并发模型建立在对象和监视器(Monitor)的概念之上。在Java中，每个对象都可以作为一个监视器，通过synchronized关键字来实现互斥访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设计源自Smalltalk语言，非常符合面向对象的思维，对象既包含数据，也负责保护这些数据的并发访问。</p>
<h3 id="1-2-Go：基于CSP的并发模型"><a href="#1-2-Go：基于CSP的并发模型" class="headerlink" title="1.2 Go：基于CSP的并发模型"></a>1.2 Go：基于CSP的并发模型</h3><p>相比之下，Go语言在设计之初就考虑到了多核时代的并发需求。它没有选择基于共享内存的并发模型，而是采用了通信顺序进程(CSP)理论：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i  <span class="comment">// 发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        val := &lt;-ch  <span class="comment">// 接收数据  </span></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的设计哲学是“通过通信来共享内存，而不是通过共享内存来通信”。这句话体现了Go对并发的根本思路。</p>
<h3 id="1-3-Java线程调度"><a href="#1-3-Java线程调度" class="headerlink" title="1.3 Java线程调度"></a>1.3 Java线程调度</h3><p>Java线程直接映射到操作系统线程，调度依赖操作系统：</p>
<ul>
<li>优点：可以充分利用操作系统的调度能力</li>
<li>缺点：上下文切换成本高，并发数量受限</li>
</ul>
<h3 id="1-4-Go运行时调度"><a href="#1-4-Go运行时调度" class="headerlink" title="1.4 Go运行时调度"></a>1.4 Go运行时调度</h3><p>Go实现了自己的调度器(GMP模型)：</p>
<ul>
<li>G (Goroutine)：协程</li>
<li>M (Machine)：工作线程</li>
<li>P (Processor)：处理器</li>
</ul>
<p>调度流程：</p>
<ol>
<li>G创建后进入P的本地队列或全局队列</li>
<li>M绑定P后不断从队列获取G执行</li>
<li>当G发生阻塞，M会寻找其他G执行</li>
<li>当M阻塞，P会寻找其他M</li>
</ol>
<p>这种设计带来的优势：</p>
<ol>
<li>轻量级上下文切换</li>
<li>工作窃取式负载均衡</li>
<li>自动伸缩的M数量</li>
</ol>
<h2 id="二、并发单元"><a href="#二、并发单元" class="headerlink" title="二、并发单元"></a>二、并发单元</h2><h3 id="2-1-Java线程与系统线程一对一映射"><a href="#2-1-Java线程与系统线程一对一映射" class="headerlink" title="2.1 Java线程与系统线程一对一映射"></a>2.1 Java线程与系统线程一对一映射</h3><p>Java主要通过线程（Thread）和线程池（ThreadPool）来实现并发。传统的Java线程直接映射到操作系统的线程。这种设计导致：</p>
<ol>
<li>内存消耗大，默认情况下，每个线程的栈大小为1MB或更多</li>
<li>创建和销毁线程的开销较大，创建和销毁线程需要较多的系统资源，频繁创建和销毁线程可能会导致性能问题</li>
<li>Java线程的调度是由操作系统负责的，这意味着线程的上下文切换开销大，并且线程数量受系统限制</li>
</ol>
<p>为了缓解上述问题，Java引入了线程池的概念。线程池可以重用已创建的线程，减少线程创建和销毁的开销，并且可以控制并发线程的数量。</p>
<p>启动一个Java线程的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>一个Java线程池示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line">executor.shutdown(); </span><br></pre></td></tr></table></figure>

<h3 id="2-2-Go协程"><a href="#2-2-Go协程" class="headerlink" title="2.2 Go协程"></a>2.2 Go协程</h3><p>相比之下，Go语言的协程（goroutine）是一种语言级的轻量级线程，由Go运行时而不是操作系统来调度。这带来了几个显著优势：</p>
<ol>
<li>创建成本极低（仅2KB的初始栈）</li>
<li>可以轻松创建上万个协程</li>
<li>调度切换成本低</li>
</ol>
<p>看看启动一个Go协程有多简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 任务代码  </span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>Java vs Go：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Java Thread</th>
<th>Go Goroutine</th>
</tr>
</thead>
<tbody><tr>
<td>内存占用</td>
<td>约1MB</td>
<td>约2KB</td>
</tr>
<tr>
<td>创建成本</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>调度模型</td>
<td>操作系统调度</td>
<td>Go运行时调度</td>
</tr>
<tr>
<td>上下文切换开销</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>并发数量级</td>
<td>数千</td>
<td>数十万</td>
</tr>
</tbody></table>
<h2 id="三、同步原语"><a href="#三、同步原语" class="headerlink" title="三、同步原语"></a>三、同步原语</h2><p>Java的同步原语设计体现了“面向对象””和“功能完备性”的追求。它提供了丰富的API和强大的功能特性，允许开发者根据具体场景进行精细化的控制。比如ReentrantLock不仅提供基本的加锁解锁功能，还支持锁的公平性选择、等待中断、条件变量等高级特性。</p>
<p>相比之下，Go的同步原语设计体现了”简洁性”和”实用性”的理念。它提供了最必要的同步机制，并通过简洁的API设计降低使用复杂度。Go更推荐通过channel进行同步通信，互斥锁等同步原语作为补充手段。</p>
<p>Java提供了完整的锁体系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量</span></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>Go则提供了更简洁的同步工具：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁</span></span><br><span class="line"><span class="keyword">var</span> rwmu sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件等待</span></span><br><span class="line"><span class="keyword">var</span> cond sync.Cond</span><br><span class="line"></span><br><span class="line"><span class="comment">// WaitGroup用于等待一组goroutine完成</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br></pre></td></tr></table></figure>

<p>Go vs Java，不同场景下的选择：</p>
<ol>
<li><p>简单的互斥访问</p>
<ul>
<li>Java: synchronized或ReentrantLock</li>
<li>Go: sync.Mutex</li>
</ul>
</li>
<li><p>读多写少场景</p>
<ul>
<li>Java: ReentrantReadWriteLock</li>
<li>Go: sync.RWMutex或channel</li>
</ul>
</li>
<li><p>条件等待场景</p>
<ul>
<li>Java: Condition</li>
<li>Go: channel优先，必要时使用sync.Cond</li>
</ul>
</li>
<li><p>原子操作场景</p>
<ul>
<li>Java: Atomic类家族</li>
<li>Go: atomic包</li>
</ul>
</li>
</ol>
<h3 id="3-1-互斥锁的实现机制"><a href="#3-1-互斥锁的实现机制" class="headerlink" title="3.1 互斥锁的实现机制"></a>3.1 互斥锁的实现机制</h3><h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><p>Java的ReentrantLock采用了基于AQS的实现。AQS维护了一个虚拟的CLH队列来管理等待的线程。当锁被占用时，后续请求锁的线程会被包装成Node节点加入队列。这种设计支持了：</p>
<ol>
<li>可重入性：通过计数器记录重入次数</li>
<li>公平性选择：支持公平锁和非公平锁</li>
<li>等待可中断：支持响应中断信号</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Go实现"><a href="#Go实现" class="headerlink" title="Go实现"></a>Go实现</h4><p>Go的sync.Mutex则采用了更轻量级的实现。它使用两个字段：</p>
<ol>
<li>state： 表示锁的状态（0表示未锁定）</li>
<li>sema： 用于控制等待队列</li>
</ol>
<p>这种简化的设计带来了更低的内存占用和更快的加锁&#x2F;解锁速度，但功能相对简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu    sync.Mutex</span><br><span class="line">    count <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Increment() &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    c.count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go vs Java：</p>
<ol>
<li>语言级支持：Go通过defer机制优雅处理锁释放</li>
<li>功能特性：Java的ReentrantLock支持可重入，而Go的sync.Mutex不支持</li>
<li>公平性：Java支持配置公平&#x2F;非公平锁，Go只提供非公平锁</li>
<li>锁状态：Java支持查询锁状态，Go不支持</li>
</ol>
<h3 id="3-2-读写锁"><a href="#3-2-读写锁" class="headerlink" title="3.2 读写锁"></a>3.2 读写锁</h3><h4 id="Java实现-1"><a href="#Java实现-1" class="headerlink" title="Java实现"></a>Java实现</h4><p>Java的ReadWriteLock接口由ReentrantReadWriteLock实现。其核心特性包括：</p>
<ol>
<li>读写分离：支持多个读操作并发</li>
<li>重入支持：同一线程可多次获取读锁或写锁</li>
<li>锁降级：支持写锁降级为读锁</li>
<li>公平性选择：支持公平和非公平模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种实现允许：</p>
<ol>
<li>读线程并发访问</li>
<li>写线程独占访问</li>
<li>读写锁可降级，避免数据更新期间产生的竞争</li>
</ol>
<h4 id="Go实现-1"><a href="#Go实现-1" class="headerlink" title="Go实现"></a>Go实现</h4><p>Go的sync.RWMutex实现更加简单，但有几个特性需要注意：</p>
<ol>
<li>不支持重入</li>
<li>不支持锁升级或降级</li>
<li>写锁优先级较高，避免写饥饿</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Get(key <span class="type">string</span>) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    c.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.data[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Put(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    c.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.Unlock()</span><br><span class="line">    c.data[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go vs Java：</p>
<ol>
<li>接口设计：<ul>
<li>Java分离读写锁对象</li>
<li>Go使用单一RWMutex对象</li>
</ul>
</li>
<li>锁升降级：<ul>
<li>Java支持写锁降级为读锁</li>
<li>Go不支持锁升降级</li>
</ul>
</li>
<li>性能特点：<ul>
<li>Java读写锁有更多开销但功能更丰富</li>
<li>Go读写锁实现更轻量级</li>
</ul>
</li>
</ol>
<h3 id="3-3条件变量对比"><a href="#3-3条件变量对比" class="headerlink" title="3.3条件变量对比"></a>3.3条件变量对比</h3><h4 id="Java实现-2"><a href="#Java实现-2" class="headerlink" title="Java实现"></a>Java实现</h4><p>Java的Condition基于AQS实现：</p>
<ol>
<li>每个Condition维护独立的等待队列</li>
<li>支持多个条件变量</li>
<li>提供丰富的等待&#x2F;通知机制</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T item)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(item);</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Go实现-2"><a href="#Go实现-2" class="headerlink" title="Go实现"></a>Go实现</h4><p>Go的sync.Cond：</p>
<ol>
<li>基于简单的等待队列</li>
<li>一个Cond对应一个底层锁</li>
<li>提供基本的等待&#x2F;通知功能</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BoundedQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    cond    *sync.Cond</span><br><span class="line">    queue   []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBoundedQueue</span><span class="params">(capacity <span class="type">int</span>)</span></span> *BoundedQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;BoundedQueue&#123;</span><br><span class="line">        cond:     sync.NewCond(&amp;sync.Mutex&#123;&#125;),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BoundedQueue)</span></span> Put(item <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == q.capacity &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    q.queue = <span class="built_in">append</span>(q.queue, item)</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *BoundedQueue)</span></span> Take() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    q.cond.L.Lock()</span><br><span class="line">    <span class="keyword">defer</span> q.cond.L.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(q.queue) == <span class="number">0</span> &#123;</span><br><span class="line">        q.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    item := q.queue[<span class="number">0</span>]</span><br><span class="line">    q.queue = q.queue[<span class="number">1</span>:]</span><br><span class="line">    q.cond.Signal()</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go vs Java：</p>
<ol>
<li>条件变量创建：<ul>
<li>Java支持一个锁创建多个条件变量</li>
<li>Go一个sync.Cond绑定一个锁</li>
</ul>
</li>
<li>通知机制：<ul>
<li>Java提供signal()和signalAll()</li>
<li>Go提供Signal()和Broadcast()</li>
</ul>
</li>
<li>使用方式：<ul>
<li>Java显式管理Lock和Condition</li>
<li>Go通过sync.Cond封装底层锁</li>
</ul>
</li>
</ol>
<h3 id="3-4原子操作对比"><a href="#3-4原子操作对比" class="headerlink" title="3.4原子操作对比"></a>3.4原子操作对比</h3><h4 id="Java实现-3"><a href="#Java实现-3" class="headerlink" title="Java实现"></a>Java实现</h4><p>Java的原子类设计体现了面向对象的思想，提供了一系列完整的原子类：</p>
<ul>
<li>基本类型：AtomicInteger、AtomicLong、AtomicBoolean</li>
<li>引用类型：AtomicReference、AtomicStampedReference</li>
<li>数组类型：AtomicIntegerArray、AtomicLongArray</li>
<li>属性更新器：AtomicIntegerFieldUpdater、AtomicReferenceFieldUpdater</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicCounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        value.addAndGet(delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Go实现-3"><a href="#Go实现-3" class="headerlink" title="Go实现"></a>Go实现</h4><p>Go则采用了更加功能性的设计思路，通过atomic包提供基础的原子操作：</p>
<ul>
<li>基本数值类型：Int32、Int64、Uint32、Uint64</li>
<li>指针操作：Pointer</li>
<li>值类型：Value（通用原子类型）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AtomicCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">    value atomic.Int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AtomicCounter)</span></span> Increment() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.value.Add(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AtomicCounter)</span></span> Decrement() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.value.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AtomicCounter)</span></span> Add(delta <span class="type">int64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.value.Add(delta)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *AtomicCounter)</span></span> Get() <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.value.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go vs Java：</p>
<ol>
<li>API设计：<ul>
<li>Java提供丰富的原子类型和操作</li>
<li>Go提供基础的原子操作包</li>
</ul>
</li>
<li>功能支持：<ul>
<li>Java支持CAS操作链和复合操作</li>
<li>Go主要支持基本的原子操作</li>
</ul>
</li>
<li>性能特性：<ul>
<li>Java原子类实现了更多优化</li>
<li>Go原子操作更接近底层</li>
</ul>
</li>
</ol>
<h2 id="四、内存模型"><a href="#四、内存模型" class="headerlink" title="四、内存模型"></a>四、内存模型</h2><h3 id="4-1-Java内存模型-JMM"><a href="#4-1-Java内存模型-JMM" class="headerlink" title="4.1 Java内存模型(JMM)"></a>4.1 Java内存模型(JMM)</h3><p>Java内存模型定义了一套复杂的规则，来保证多线程程序的可见性、有序性和原子性：</p>
<ol>
<li>volatile关键字保证可见性</li>
<li>synchronized保证原子性</li>
<li>happens-before规则保证有序性</li>
</ol>
<p>这需要开发者对内存屏障、重排序等概念有深入理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入volatile变量会强制将缓存写回主存</span></span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 读取volatile变量会强制从主存刷新</span></span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// busy wait</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Go内存模型"><a href="#4-2-Go内存模型" class="headerlink" title="4.2 Go内存模型"></a>4.2 Go内存模型</h3><p>Go的内存模型相对简单，主要基于happens-before原则：</p>
<ol>
<li>channel操作隐含的happens-before关系</li>
<li>sync.Mutex等同步原语的happens-before保证</li>
<li>无需显式的内存屏障</li>
</ol>
<p>看一个Go的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; a = <span class="string">&quot;hello&quot;</span> &#125;()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是有数据竞争的。要修复它，我们需要用channel来建立happens-before关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line">ch ：= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">    a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; </span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ch  <span class="comment">// 建立happens-before关系</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Java的坑"><a href="#4-3-Java的坑" class="headerlink" title="4.3 Java的坑"></a>4.3 Java的坑</h3><p>在学习Java多线程开发时，常会学习这样一个经典案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LateInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Resource resource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LateInitialization.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查</span></span><br><span class="line">                    resource = <span class="keyword">new</span> <span class="title class_">Resource</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段看似正确的双重检查锁定(Double-Checked Locking)代码实际上是有问题的。因为Resource对象的构造过程可能被重排序，导致其他线程看到一个尚未完全初始化的对象。要修复这个问题，我们需要将resource声明为volatile：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Resource resource;</span><br></pre></td></tr></table></figure>

<p>而在Go中，类似的场景就简单得多：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> resource *Resource</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Resource &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        resource = &amp;Resource&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go通过sync.Once提供了一个简洁且线程安全的解决方案。</p>
<h2 id="五、错误处理"><a href="#五、错误处理" class="headerlink" title="五、错误处理"></a>五、错误处理</h2><h3 id="5-1-Java的异常传播"><a href="#5-1-Java的异常传播" class="headerlink" title="5.1 Java的异常传播"></a>5.1 Java的异常传播</h3><p>在Java的并发编程中，异常处理是一个比较棘手的问题。线程中抛出的异常如果没有被捕获，整个程序可能不会收到任何通知：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionInThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread continues...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了处理这个问题，我们通常需要设置UncaughtExceptionHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.setUncaughtExceptionHandler((thread, e) -&gt; &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Thread &quot;</span> + thread.getName() + <span class="string">&quot; threw &quot;</span> + e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Go的错误处理"><a href="#5-2-Go的错误处理" class="headerlink" title="5.2 Go的错误处理"></a>5.2 Go的错误处理</h3><p>Go采用了不同的方式。首先，panic在一个goroutine中发生时，如果没有被recover，整个程序会退出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Oops!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主goroutine sleep一段时间，等待panic发生</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种设计强制我们必须认真对待每个goroutine中可能发生的panic。通常的做法是在每个goroutine的顶层函数中使用defer和recover：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Recovered from panic: %v&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可能panic的代码</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" data-id="cmhesos9e000344uren5de0v1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/06/21/%E6%B7%B1%E5%85%A5LLM%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%89%8B%E6%92%95%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A(Transformer)%EF%BC%81%20-%20%E5%89%AF%E6%9C%AC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
<aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/shiro-mockmvc/" rel="tag">shiro mockmvc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/shiro-mockmvc/" style="font-size: 10px;">shiro mockmvc</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list">
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li>
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Go vs Java深入对比系列（四）：并发编程</a>
          </li>
          <li>
            <a href="/2024/06/19/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">Go vs Java深入对比系列（三）：错误处理</a>
          </li>
          <li>
            <a href="/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">Go vs Java深入对比系列（二）：类型系统</a>
          </li>
          <li>
            <a href="/2024/05/30/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/">Go vs Java深入对比系列（一）：语言设计哲学</a>
          </li>
          <li>
            <a href="/2023/11/13/%E6%B7%B1%E5%85%A5LLM%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%89%8B%E6%92%95%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A(Transformer)%EF%BC%81/">深入LLM基础，手撕变形金刚(Transformer)！</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 lcz的技术小窝<br>
      Powered by <a href="https://hexo.io/" target="_blank">lcz的技术小窝</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章列表</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>