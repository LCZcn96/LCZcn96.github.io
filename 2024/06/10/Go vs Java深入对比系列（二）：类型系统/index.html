<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Go vs Java深入对比系列（二）：类型系统一、 变量声明方式Go语言提供了多种变量声明方式： 1234567891011121314&#x2F;&#x2F; 标准声明，类型在变量名字后面，末尾不需要加分号var a intvar a int &#x3D; 10&#x2F;&#x2F; 短变量声明（只能在函数内部使用），这种声明方式类似Python，但与Python不同的是，go是静态语言，由go编译器进行自动类型推导a :&#x3D; 10 &#x2F;&#x2F; 批">
<meta property="og:type" content="article">
<meta property="og:title" content="lcz的技术小窝">
<meta property="og:url" content="http://example.com/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Go vs Java深入对比系列（二）：类型系统一、 变量声明方式Go语言提供了多种变量声明方式： 1234567891011121314&#x2F;&#x2F; 标准声明，类型在变量名字后面，末尾不需要加分号var a intvar a int &#x3D; 10&#x2F;&#x2F; 短变量声明（只能在函数内部使用），这种声明方式类似Python，但与Python不同的是，go是静态语言，由go编译器进行自动类型推导a :&#x3D; 10 &#x2F;&#x2F; 批">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-06-10T03:23:32.701Z">
<meta property="article:modified_time" content="2024-06-10T03:33:18.579Z">
<meta property="article:author" content="lcz的技术小窝">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lcz的技术小窝</a>
      </h1>
      <p style="font-size: 14px; color: #a6c7b3; margin-top: 5px;">业精于勤，而荒于嬉</p>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">文章列表</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Go vs Java深入对比系列（二）：类型系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-06-10T03:23:32.701Z" itemprop="datePublished">2024-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Go-vs-Java深入对比系列（二）：类型系统"><a href="#Go-vs-Java深入对比系列（二）：类型系统" class="headerlink" title="Go vs Java深入对比系列（二）：类型系统"></a>Go vs Java深入对比系列（二）：类型系统</h1><h2 id="一、-变量声明方式"><a href="#一、-变量声明方式" class="headerlink" title="一、 变量声明方式"></a>一、 变量声明方式</h2><p>Go语言提供了多种变量声明方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准声明，类型在变量名字后面，末尾不需要加分号</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 短变量声明（只能在函数内部使用），这种声明方式类似Python，但与Python不同的是，go是静态语言，由go编译器进行自动类型推导</span></span><br><span class="line">a := <span class="number">10</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量声明</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">string</span></span><br><span class="line">    c <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java的变量声明则相对严格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型声明必须指定类型，并且以分号结束</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Tony&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种差异背后体现了两种语言对“显式”和“隐式”的不同态度。Go语言通过变量声明的多样性，试图在显式性和便利性之间找到平衡：</p>
<ul>
<li><code>:=</code>短变量声明让代码更简洁，但仅限于函数内部使用，避免了全局作用域的隐式行为</li>
<li>批量声明使代码更有组织性，特别是在声明相关变量时</li>
<li><code>var</code>关键字明确告诉代码阅读者“这是一个变量声明”</li>
</ul>
<p>Go的一个重要特性是其”零值”机制。任何变量在声明后都会获得一个可用的”零值”：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go的变量声明会自动初始化为零值，需要注意的是数值类型的零值为 0 ，字符串的零值为 &quot;&quot; ，布尔的零值为false ， 指针的零值为 nil 。</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span>     <span class="comment">// s = &quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span>        <span class="comment">// i = 0</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>       <span class="comment">// p = nil</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  <span class="comment">// m = nil</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span>      <span class="comment">// slice = nil</span></span><br></pre></td></tr></table></figure>
<p>这是一个深思熟虑的设计。通过保证每个变量都有一个合理的初始状态，Go大大降低了程序中未初始化变量导致的错误风险。</p>
<p>相比之下，Java的处理则更为谨慎：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;          <span class="comment">// 类字段：会自动初始化为0</span></span><br><span class="line">    String s;       <span class="comment">// 类字段：会自动初始化为null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> j;      <span class="comment">// 局部变量：必须显式初始化后才能使用</span></span><br><span class="line">        String str; <span class="comment">// 局部变量：必须显式初始化后才能使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java区分了成员变量和局部变量的处理方式，如果编译器确认一个局部变量在使用之前可能没有被初始化，编译器将报错。这增加了开发者的心智负担，但也强制开发者必须思考变量的初始化问题。</p>
<h2 id="二、-类型系统"><a href="#二、-类型系统" class="headerlink" title="二、 类型系统"></a>二、 类型系统</h2><p>尽管Go和Java都是静态类型语言，它们在数据类型的设计和使用上还是有一些区别：<br>Go语言和Java一样，都提供了一些原生的数据类型，包括:</p>
<table>
<thead>
<tr>
<th>Go</th>
<th>Java</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>boolean</td>
</tr>
<tr>
<td>int8， int16， int32， int64</td>
<td>byte， short， int， long</td>
</tr>
<tr>
<td>uint8， uint16， uint32， uint64</td>
<td>无</td>
</tr>
<tr>
<td>float32， float64</td>
<td>float， double</td>
</tr>
<tr>
<td>complex64， complex128</td>
<td>无</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
</tbody></table>
<p>可以看到，尽管有些类型的名字不太一样，但基本覆盖了布尔型、整型、浮点型这些常见的类型。不过也有几点区别:</p>
<ul>
<li>Go额外提供了无符号整型uint，而Java没有。  </li>
<li>Go提供了复数类型complex，而Java没有。</li>
<li>Go的字符串类型是string，是原生类型；而Java用的是String类。</li>
<li>Java有单独的字符类型char，而Go却没有。在Go中，rune类型实际上就是int32的别名，常用来表示Unicode码。</li>
</ul>
<p><strong>平台无关类型和平台相关类型</strong></p>
<p>Go语言的数值类型还分为平台无关类型和平台相关类型。平台无关类型包括int8、uint8、int16、uint16、int32、uint32、int64、uint64等，它们在任何平台上所占的位数都是固定的。而平台相关类型包括int、uint和uintptr，它们的位数则取决于构建代码的平台：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>32位平台</th>
<th>64位平台</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32位</td>
<td>64位</td>
</tr>
<tr>
<td>uint</td>
<td>32位</td>
<td>64位</td>
</tr>
<tr>
<td>uintptr</td>
<td>32位</td>
<td>64位</td>
</tr>
</tbody></table>
<p>以int类型为例，在32位平台上它是32位的，而在64位平台上则是64位的。所以在跨平台的代码中，应该尽量使用平台无关类型，避免位数的差异导致的问题。而平台相关类型通常只在低层系统编程或者性能优化时使用。</p>
<p>而在Java中，大部分原生类型都是固定位数的，不受平台影响。不过也有一些例外，比如long类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>32位平台</th>
<th>64位平台</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>32位</td>
<td>32位</td>
</tr>
<tr>
<td>long</td>
<td>32位</td>
<td>64位</td>
</tr>
<tr>
<td>long long</td>
<td>64位</td>
<td>64位</td>
</tr>
</tbody></table>
<p>在一些32位的JVM实现中(如32位Windows系统)，long占4个字节也就是32位的。但在主流的64位平台上，long是64位。不过这种差异很少会影响到普通的Java程序。</p>
<p><strong>数组</strong></p>
<p>说到数组，Java和Go就有了很大的不同。在Java中，数组是引用类型。声明一个数组需要指定元素类型和数组长度，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这里的arr是一个引用，指向一个包含5个int类型元素的数组对象。数组的元素在没有显式初始化的情况下，会被赋予类型的默认值。<br>我们也可以在声明时直接提供初始值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>而在Go语言中，数组是值类型。声明数组时同样需要指定元素类型和数组长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有显式初始化时，内部默认为零值，等价于0,0,0,0,0</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在声明时提供初始值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以在声明时提供部分初始值，缺失位置为零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于1, 2, 3, 0, 0</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>与Java不同的是，Go还支持让编译器根据初始值的个数自动推断数组长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 [5]int&#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br></pre></td></tr></table></figure>

<p>此外，Go还支持使用索引来初始化数组的特定元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于 [5]int&#123;0, 10, 0, 30, 0&#125;</span></span><br><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125; </span><br></pre></td></tr></table></figure>


<p>从内存布局上看，Java的数组对象本身是分配在堆内存上的，而数组元素则可能在堆或者栈上。而Go的数组则总是分配在连续的内存上。如果数组是函数的局部变量，那么整个数组都会在栈上分配。</p>
<p>此外，Go的数组是值语义，赋值或者传参时会复制整个数组。而Java的数组是引用语义，赋值或传参时只复制引用。</p>
<p>Java中的数组是引用类型，这意味着你可以将一个数组赋值给另一个数组，它们会指向同一个数组对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = arr1;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<p>改变arr2的元素，也会影响到arr1，因为它们本质上是同一个数组。</p>
<p>而Go的数组是值类型，赋值或传参会复制整个数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">arr2 := arr1</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">fmt.Println(arr1[<span class="number">0</span>]) <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>改变arr2不会影响到arr1，因为它们是两个完全独立的数组。</p>
<p>这种差异会影响到数组作为函数参数时的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">foo(arr);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arr [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">foo(arr)</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>]) <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>在Java中，函数内部对数组元素的修改会影响到原数组。而在Go中,函数内部得到的是数组的一个副本，对它的修改不会影响原数组。</p>
<p>如果你想在Go中实现类似Java的引用传递效果，可以使用数组指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">foo(&amp;arr)</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>]) <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<p><strong>多维数组</strong></p>
<p>Java支持多维数组，实际上是数组的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>这里的arr是一个包含3个元素的数组，每个元素又是一个包含4个int类型元素的数组。</p>
<p>Go也支持多维数组，但实现方式不同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>这里的arr是一个真正的二维数组，内存是连续分配的。</p>
<p><strong>数组的长度</strong></p>
<p>在Java中，数组的长度可以通过length属性获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arr.length); <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>

<p>在Go中，可以使用内置的len函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr)) <span class="comment">// 输出3</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Go中数组的长度是类型的一部分。[3]int和[4]int是两种不同的类型。而在Java中，数组的长度与类型无关。</p>
<p><strong>切片</strong></p>
<p>在go语言中，我们使用切片要多过使用数组。切片(slice)是数组的一个视图。它提供了一种方便且高效的方式来操作数组的一部分。切片本身并不拥有任何数据，它只是描述了底层数组的一个片段。可以用望远镜来类比切片——望远镜本身不存储你看到的风景，它只是提供了一个观察窗口。同样，切片也只是提供了观察数组的”窗口”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>这里的slice就是一个切片，它描述了数组arr的一个片段，从索引1(包含)到索引4(不包含)，也就是{2, 3, 4}。</p>
<p>Java中没有切片的概念，但可以通过Arrays.copyOfRange()方法来获取数组的一部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] slice = Arrays.copyOfRange(arr, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>这会创建一个新的数组slice，包含arr[1]到arr[3]的元素。</p>
<p>除了从数组或其他切片创建切片外,Go还提供了内置的make函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这会创建一个长度为3,容量为5的int类型的切片。底层数组会在堆上分配。</p>
<p>类似地,Java可以使用Arrays.copyOf方法来创建一个新的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] slice = Arrays.copyOf(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>], <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这会创建一个长度为3,容量为5的int数组。</p>
<p>在Go中，切片由三部分组成：</p>
<ul>
<li>指向底层数组的指针</li>
<li>切片的长度(length) </li>
<li>切片的容量(capacity)</li>
</ul>
<p>其中,长度表示切片中元素的数量，容量表示切片起始位置到底层数组末尾的元素数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 输出3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 输出4</span></span><br></pre></td></tr></table></figure>

<p><strong>切片的遍历</strong></p>
<p>在Go中，可以使用for range语法轻松遍历切片：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> slice &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;index: %d, value: %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java中,可以使用普通的for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] slice = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slice.length; i++) &#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;index: %d, value: %d\n&quot;</span>, i, slice[i]);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>或者使用增强型for循环(forEach)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v : slice) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片提供了比数组更强大、更灵活的操作方式：</p>
<ol>
<li>可以很方便地获取数组的一部分。</li>
<li>可以通过改变切片的长度来动态改变切片的大小(最大不超过容量)。</li>
<li>多个切片可以共享同一个底层数组，节省内存空间。</li>
<li>内置的append函数可以方便地向切片添加元素，切片会自动扩容（扩容会改变底层数组）。</li>
</ol>
<p><strong>切片的坑</strong></p>
<p>正因为切片共享底层数组，在使用时也需要注意一些坑：</p>
<ol>
<li>当多个切片共享同一个数组时，对一个切片的修改会影响到其他切片。</li>
<li>当切片的容量用尽后，再次append会导致重新分配内存，此时就不再与原数组共享内存了。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice1 := arr[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// 切片的容量是从子切片的起点，到底层数组的终点</span></span><br><span class="line"></span><br><span class="line">slice2 := arr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出[2 3 4]</span></span><br><span class="line">fmt.Println(slice2) <span class="comment">// 输出[3 4 5]</span></span><br><span class="line"></span><br><span class="line">slice1 = <span class="built_in">append</span>(slice1, <span class="number">6</span>)</span><br><span class="line">fmt.Println(arr)    <span class="comment">// 输出[1 2 3 4 6]</span></span><br><span class="line">fmt.Println(slice1) <span class="comment">// 输出[2 3 4 6]</span></span><br><span class="line">fmt.Println(slice2) <span class="comment">// 输出[3 4 6]  </span></span><br></pre></td></tr></table></figure>

<p>这里slice1和slice2共享同一个底层数组。当slice1添加元素时,会影响到原数组和slice2。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice := <span class="built_in">append</span>(slice, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">fmt.Println(arr)      <span class="comment">// 输出[1 2 3 4 5]  </span></span><br><span class="line">fmt.Println(slice)    <span class="comment">// 输出[2 3]</span></span><br><span class="line">fmt.Println(newSlice) <span class="comment">// 输出[2 3 6 7 8]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，因为slice的容量只有2，当添加3个元素时，会重新分配内存。此时newSlice就不再与arr共享内存了。</p>
<p>切片扩容策略：<br>    当容量小于 256 的时候，两倍扩容；<br>    否则，按照 1.25 扩容。<br>ps：低版本是 1024 作为分界点。</p>
<p>在使用切片时我们最好预估切片最终的大小，使用make预分配可以避免切片多次扩容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能不好的写法</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10000</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可能，尽量复用已有的切片而不是创建新的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性能不好的写法</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> items &#123;</span><br><span class="line">    processed := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 处理v...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">processed := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(items))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> items &#123;</span><br><span class="line">    processed = processed[:<span class="number">0</span>] <span class="comment">// 清空切片但保留容量</span></span><br><span class="line">    <span class="comment">// 处理v...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>数组和切片的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>切片</th>
</tr>
</thead>
<tbody><tr>
<td>直接初始化</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>make</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>访问元素</td>
<td>arr[i]</td>
<td>arr[i]</td>
</tr>
<tr>
<td>len</td>
<td>长度</td>
<td>已有元素个数</td>
</tr>
<tr>
<td>cap</td>
<td>长度</td>
<td>容量</td>
</tr>
<tr>
<td>append</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>扩容</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<p><strong>Map类型</strong></p>
<p>现在让我们来看看另一个重要的复合类型：Map。Java中的Map是一个接口，有多种实现（HashMap、TreeMap等），而Go中的map是语言内置的类型。这种差异体现了两种语言不同的设计哲学。</p>
<p>在Java中，Map是一个顶层接口，定义了键值对操作的基本行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;</span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用实现</span></span><br><span class="line">Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>这种设计的优点是灵活性强，可以根据需要选择不同的实现：</p>
<ul>
<li>HashMap：无序，O(1)的查找性能</li>
<li>TreeMap：有序，基于红黑树，O(log n)的性能</li>
<li>LinkedHashMap：保持插入顺序</li>
</ul>
<p>Go则采用了更简单的方案，只提供了一种内置的map类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用字面量语法</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;apple&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;banana&quot;</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作</span></span><br><span class="line">m[<span class="string">&quot;orange&quot;</span>] = <span class="number">3</span>        <span class="comment">// 插入</span></span><br><span class="line">value := m[<span class="string">&quot;apple&quot;</span>]    <span class="comment">// 读取</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;banana&quot;</span>)    <span class="comment">// 删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断key是否存在</span></span><br><span class="line"><span class="keyword">if</span> value, ok := m[<span class="string">&quot;apple&quot;</span>]; ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;存在，值为: %d\n&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go的map虽然看起来简单，但有一些特性需要特别注意：</p>
<ol>
<li>并发不安全</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样做是危险的！</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;key&quot;</span>] = <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _ = m[<span class="string">&quot;key&quot;</span>]</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>如果需要并发安全的map，我们有两个选择：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择1：使用sync.Map</span></span><br><span class="line"><span class="keyword">var</span> sm sync.Map</span><br><span class="line">sm.Store(<span class="string">&quot;key&quot;</span>, value)</span><br><span class="line">val, ok := sm.Load(<span class="string">&quot;key&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择2：使用互斥锁保护普通map</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeWrite</span><span class="params">(key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">    m[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>键的类型限制</li>
</ol>
<p>Go的map键类型必须是可比较的（comparable），这意味着函数、切片、包含切片的结构体都不能作为键：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些都是非法的</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[[]<span class="type">int</span>]<span class="type">string</span>)           <span class="comment">// 切片不能作为键</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="function"><span class="keyword">func</span><span class="params">()</span></span>]<span class="type">string</span>)          <span class="comment">// 函数不能作为键</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>]<span class="type">string</span>)  <span class="comment">// map不能作为键</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>内存管理</li>
</ol>
<p>Go的map会自动扩容，但不会自动收缩。如果你删除了大量的键值对，需要考虑重建map来释放内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果删除了大量数据后，可以通过重建map来收缩内存</span></span><br><span class="line">oldMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line"><span class="comment">// ... 填充数据后删除了大量键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重建map来收缩内存</span></span><br><span class="line">newMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(oldMap))</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[k] = v</span><br><span class="line">&#125;</span><br><span class="line">oldMap = newMap</span><br></pre></td></tr></table></figure>

<p><strong>类型转换</strong></p>
<p>Go不支持隐式类型转换，即使是底层类型相同的情况下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> j <span class="type">int32</span> = i  <span class="comment">// 编译错误：不同类型间不能隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须显式转换</span></span><br><span class="line">j = <span class="type">int32</span>(i)</span><br></pre></td></tr></table></figure>

<p>这种设计乍看有些死板，但这恰恰体现了Go对类型安全的重视。当然这样在做开发时就比较麻烦了，不过正如Go语言作者Rob Pike所说，“显式的代码优于隐式的代码”。毕竟类型转换常常会导致一些难以排查的bug。显式的类型转换，迫使开发者思考每一个类型转换的合理性，从而在编码阶段就能发现潜在的问题。也使得代码更易于阅读，减少了出错的可能。</p>
<p>Java则采取了一个折中的方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> i;    <span class="comment">// 隐式转换：安全</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l;     <span class="comment">// 编译错误：可能丢失精度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>)l;  <span class="comment">// 显式转换：允许</span></span><br></pre></td></tr></table></figure>

<p>Java允许”安全”的隐式转换（如int到long），但要求”不安全”的转换必须显式进行。</p>
<p>Go的类型系统设计虽然看似限制更多，但实际上通过这些”限制”，反而为我们创造了更安全、更可维护的代码环境。这也许就是Go语言的设计者们想要追求的目标，通过合理的限制来获得更大的自由。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" data-id="cmhesos9d000244urbyjn7zpy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/06/10/%E5%BA%93%E5%AD%98%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8Redis%E6%89%9B%E4%BD%8F%E7%99%BE%E4%B8%87QPS%EF%BC%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
<aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/shiro-mockmvc/" rel="tag">shiro mockmvc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/shiro-mockmvc/" style="font-size: 10px;">shiro mockmvc</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list">
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li>
        <li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li>
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/21/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Go vs Java深入对比系列（四）：并发编程</a>
          </li>
          <li>
            <a href="/2024/06/19/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">Go vs Java深入对比系列（三）：错误处理</a>
          </li>
          <li>
            <a href="/2024/06/10/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">Go vs Java深入对比系列（二）：类型系统</a>
          </li>
          <li>
            <a href="/2024/05/30/Go%20vs%20Java%E6%B7%B1%E5%85%A5%E5%AF%B9%E6%AF%94%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/">Go vs Java深入对比系列（一）：语言设计哲学</a>
          </li>
          <li>
            <a href="/2023/11/13/%E6%B7%B1%E5%85%A5LLM%E5%9F%BA%E7%A1%80%EF%BC%8C%E6%89%8B%E6%92%95%E5%8F%98%E5%BD%A2%E9%87%91%E5%88%9A(Transformer)%EF%BC%81/">深入LLM基础，手撕变形金刚(Transformer)！</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 lcz的技术小窝<br>
      Powered by <a href="https://hexo.io/" target="_blank">lcz的技术小窝</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">文章列表</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>